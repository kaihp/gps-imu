/*
 * Solomon Systec Products SSD1306 128x64/32 Dot Matric
 * OLED/PLED Segment/Common Driver Controller
 * http://www.solomon-systech.com/
 *
 * Driver for Raspberry Pi 3 written by
 * Kai Harrekilde-Petersen (C) 2017
 *
 * 0.91" 128x32 module bought off Aliexpress.com
 * Connect VCC to 5V as the module has internal 3.3V LDO (Torex XC6206)
 */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#include "i2c.h"
#include "fonts.h"
#include "ssd1306.h"
#include "ssd1306_regs.h"

#define VERSION "0.0.3"

static int __width, __height;
uint8_t *gfxbuf = NULL; /* Graphics buffer */
int ssd_x, ssd_y; /* coords inside OLED display. (0,0) is the Upper/Left corner */
font_t *ssd_font;

void ssd130x_power(int fd, int on)
{
  /* Powering up not controlled in SW */
  return;
}

void ssd130x_reset(int fd)
{
  /* No-op */
  return;
}

void ssd_cmd1(int fd, uint8_t c0)
{
  i2c_wr8(fd, SSD_C, c0);
}

void ssd_cmd2(int fd, uint8_t c0, uint8_t c1)
{
  i2c_wr16(fd, SSD_C, (c1<<8) | c0);
}

void ssd_cmd3(int fd, uint8_t c0, uint8_t c1, uint8_t c2)
{
  uint8_t cmd[3] = {c0, c1, c2};
  i2c_wr_blk(fd, SSD_C, 3, (uint8_t *)&cmd);
}

void ssd_cmd_blk(int fd, int len, uint8_t *cmd)
{
  i2c_wr_blk(fd, SSD_C, len, cmd);
}

void ssd_dat1(int fd, uint8_t d0)
{
  i2c_wr8(fd, SSD_D, d0);
}

void ssd_dat2(int fd, uint8_t d0, uint8_t d1)
{
  i2c_wr16(fd, SSD_D, (d1 << 8) | d0);
}

void ssd_dat_blk(int fd, int len, uint8_t *data)
{
  i2c_wr_blk(fd, SSD_D, len, data);
}

void ssd130x_init(int fd, int w, int h)
{
  if(w!=128 || (h!=32 && h!=64)) {
    exit(-1);
  }
  __width=w;
  __height=h;
/*

 * Software initialization must NOT be done according to <SSD1306.pdf,
 * pg64>, as it doesn't work (trust me on this one).
 * Instead use the sequence from
 * <https://github.com/galpavlin/STM32-SSD1306/128x32/src/oled.c>:
 *  1) Set Display OFF (0xAE)
 *  2) Set Display Clock (0xD5, 0x80)
 *  3) Set MUX ratio (0xA8, 0x1F) [x32, x64=0x3F]
 *  4) Set Display offset (0xD3, 0x00)
 *  5) Set Display Start Line (0x40)
 *  6) Set Charge-pump Internal (0x8D, 0x14)
 *  7) Addressing Mode = PAGE (0x20)
 *  8) Set Segment re-map (0xA1)
 *  9) Set COM Output Scan Dir reversed (0xC8)
 * 10) Set COM pin HW config (0xDA, 0x02)
 * 11) Set Contrast Control (0x81, 0x8F)
 * 12) Set precharge period (0xD9, 0xF1)
 * 13) Set VCOMH deselect level (0xDB, 0x40)
 * 14) Set Entire display on (0xA4)
 * 15) Set Display Normal (0xA6)
 * 16) Set Scrolling = OFF (0x2E)
 * 17) Set Display ON (0xAF)
 * 18) /Clear Screen/
 */
  ssd_cmd1(fd, SSD_DISP_SLEEP);        /* 0xAE: DISP_ENTIRE_OFF */
  ssd_cmd2(fd, SSD_DCLK_DIV, 0x80);    /* 0xD5: DCLK_DIV = 0x80 */
  ssd_cmd2(fd, SSD_MUX_RATIO, 0x1F);   /* 0xA8: MUX_RATIO = 0x1F (x32 display) */
  ssd_cmd2(fd, SSD_DISP_OFFSET, 0);    /* 0xD3: DISP_OFFSET = 0 */
  ssd_cmd1(fd, SSD_DISP_ST_LINE | 0);  /* 0x40: DISP_STARTLINE = 0 */
  ssd_cmd2(fd, SSD_CHARGEPUMP, 0x14);  /* 0x8D: CHARGEPUMP = 0x14 */
  ssd_cmd2(fd, SSD_ADDR_MODE, 0);      /* 0x20: ADDR_MODE = 0h */
  ssd_cmd1(fd, SSD_SEG_REMAP127);      /* 0xA1: SEG_REMAP = Y */
  ssd_cmd1(fd, SSD_COM_SCAN_REV);      /* 0xC8: COM_SCAN = Reverse (7..0) */
  ssd_cmd2(fd, SSD_COM_HW_CFG, 0x02);  /* 0xDA: COM_HW PINS = 0x02 */
  ssd_cmd2(fd, SSD_CONTRAST, 0x8F);    /* 0x81: CONTRAST = 0x8F */
  ssd_cmd2(fd, SSD_PRECHARGE, 0xF1);   /* 0xD9: PRECHARGE = 0xF1 */
  ssd_cmd2(fd, SSD_VCOM_LVL, 0x40);    /* 0xDB: VCOMH LEVEL = 0x40 */
  ssd_cmd1(fd, SSD_DISP_ENT_NORM);     /* 0xA4: DISP_ENTIRE_RESUME */
  ssd_cmd1(fd, SSD_DISP_NORM);         /* 0xA6: DISP_NORMAL */
  ssd_cmd1(fd, SSD_SCROLL_OFF);        /* 0x2E: SCROLL = DEACTIVATE */
  ssd_cmd1(fd, SSD_DISP_AWAKE);        /* 0xAF: DISP = ON */

  /* If not allocated, allocate gfx buffer; else: zero contents */
  if(NULL==gfxbuf) {
    gfxbuf = calloc((size_t) w*h/8, sizeof(uint8_t));
    if(NULL==gfxbuf) {
      puts("Unable to allocate memory for graphics buffer");
      exit(-1);
    }
  } else {
    memset(gfxbuf, 0, (size_t) w*h/8);
  }
  /* Update GDDRAM from gfxbuf */
  ssd_disp_update(fd);
}

void ssd_disp_awake(int fd, int on)
{
  if(on) {
    i2c_wr8(fd, SSD_C, SSD_DISP_AWAKE);
  } else {
    i2c_wr8(fd, SSD_C, SSD_DISP_SLEEP);
  }
}

void ssd_disp_update(int fd)
{
  int i;
  int len=I2C_BLK_MAX;

  /* Tell which area we want to update */
  ssd_cmd3(fd, SSD_ADDR_COL, 0, __width-1);
  ssd_cmd3(fd, SSD_ADDR_PAGE, 0, (__height/8)-1);
  /* Copy from gfxbuf to display */
  for(i=0;i<__width*__height/8;i+=len) {
    ssd_dat_blk(fd, len, (uint8_t *) &gfxbuf[i]);
  }
}

void disp_init_triangle()
{
  static uint8_t img[128*32/8] = {
    /* Row 0-7, col 0-127, bit0 = topmost row, bit7 = lowest row */
    0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
    /* Row 8-15, col 0-127 */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* Row 16-23, col 0-127 */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* Row 24-31, col 0-127 */
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  memcpy(gfxbuf,&img,sizeof(img)); /* dst, src, sz */
}

void disp_init_adafruit()
{
  static uint8_t adafruit[128*32/8] = {
    /* Row 0-7, col 0-127 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* Row 8-15, col 0-127 */
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
    0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
    0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
    0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* Row 16-23, col 0-127 */
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
    0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
    0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
    0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
    0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
    0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
    0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* Row 24-31, col 0-127 */
    0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
    0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
    0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
    0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
    0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
    0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  memcpy(gfxbuf,&adafruit,sizeof(adafruit)); /* dst, src, sz */

}

void ssd_disp_clear() {
  memset(gfxbuf, 0, (size_t) ssd_width()*ssd_height()/8);
}

int ssd_width()
{
  return __width;
}

int ssd_height()
{
  return __height;
}

/*
 * The most basic function, set a single pixel
 */
void ssd_plot(uint8_t x, uint8_t y, int color)
{
  if (x<__width && y<__height) {
    int line = y >> 3;
    uint8_t byte = 1 << (y%8);
    if(color==COLOR_BLK) {
      gfxbuf[line*__width+x] &= ~byte; /* CLR */
    }
    if(color==COLOR_WHT) {
      gfxbuf[line*__width+x] |= byte; /* SET */
    }
    if(color==COLOR_INV) {
      gfxbuf[line*__width+x] ^= byte; /* INV */
    }
  }
}

void ssd_set_xy(uint8_t x, uint8_t y)
{
  ssd_x = x;
  ssd_y = y;
}

void ssd_set_font(font_t *font)
{
  ssd_font = font;
}

/*
 * Print a single glyph from the default font
 * Note: does NOT move the (x,y) coor
 */
void ssd_putc(char ch)
{
  uint64_t vscan;
  uint64_t vmask;
  uint8_t *glyphptr;
  int x,y;
  int lsl;
  if (ch<ssd_font->first || ch>ssd_font->last) {
    /* Character out of range - abort */
    return;
  }
  /* point to the first uint8_t of the chosen character */
  int idx = (ch-ssd_font->first) * ssd_font->x * ((ssd_font->y+7) >> 3);
  /* printf("ch=%02Xh font->x=%d font->y=%d glyph-idx=%d\n",ch, ssd_font->x, ssd_font->y, idx); */
  glyphptr = ssd_font->glyphs+idx;
  lsl = ssd_y -  ((8 - ssd_font->y % 8) % 8);
  vmask = (~(~0ULL << ssd_font->y)) << ssd_y;
  /* printf("ch=%02Xh x=%d y=%d lsl=%3d vmask=%08llx\n",ch,ssd_x,ssd_y,lsl,vmask); */
  /* For each column, assemble vscan, align it, and "print" it */
  for(x=0;x<ssd_font->x;x++) {
    vscan = 0;
    /* assemble complete vertical scan */
    /* printf("y_max=%d\n",((ssd_font->y+7)>>3)-1); */
    for(y=0;y<((ssd_font->y+7)>>3);y++) {
      vscan |= glyphptr[x+y*ssd_font->x] << (y*8);
    }
    /* align vscan to match destination uint8_t's */
    /* printf("%2d %08llx %08llx\n",x,vscan, (lsl>=0) ? vscan << lsl : vscan >> -lsl); */
    vscan = (lsl>=0) ? vscan << lsl : vscan >> -lsl;
    for(y=(ssd_font->y+ssd_y-1)>>3; y>=ssd_y>>3; y--) {
      int idx = __width*y + ssd_x+x;
      uint8_t tmp = gfxbuf[idx];
      tmp &= ~vmask >> 8*y; /* set pixels in glyph area */
      tmp |=  vscan >> 8*y; /* apply glyph */
      gfxbuf[idx] = tmp;  /* writeback */
    }
  }
}

void ssd_puts(const char *str)
{
  unsigned char i=0;
  while(str[i]) {
    ssd_putc(str[i]);     
    i++;
  }
}

void ssd130x_scroll_h(int fd, int dir)
{
  if(dir==0) {
    ssd_cmd1(fd, SSD_SCROLL_OFF);
  } else if (dir==1) {
    uint8_t hscroll[] = {SSD_SCROLL_H_R, 0, 0, 0, 0xF, 0, 0xFF};
    ssd_cmd_blk(fd, sizeof(hscroll), (uint8_t *)&hscroll);
    ssd_cmd1(fd, SSD_SCROLL_ON);
  } else if (dir==-11) {
    uint8_t hscroll[] = {SSD_SCROLL_H_L, 0, 0, 0, 0xF, 0, 0xFF};
    ssd_cmd_blk(fd, sizeof(hscroll), (uint8_t *)&hscroll);
    ssd_cmd1(fd, SSD_SCROLL_ON);
  }
}
 
int main (void)
{
  int i,j;
  int x,y;
  int disp = i2c_init_dev(RA_SSD1306);
  if(-1==disp) {
    puts("Failed to setup OLED display\n");
    exit(-1);
  }
  ssd130x_init(disp,128,32);
  ssd_disp_update(disp);

#if 1
  /* Font/glyph printing tests with all fonts and all implemented
   * characters
   */
  font_t *tests[] = {&font_7x5, &font_8x8, &font_21x14};
  
  for(i=0;i<sizeof(tests) / sizeof(font_t *);i++) {
    ssd_set_font(tests[i]);
    ssd_disp_clear();
    x=0;
    y=0;
    for(j=ssd_font->first;j<=ssd_font->last;j++) {
      ssd_set_xy(x,y);
      ssd_putc(j);
      x += ssd_font->x + ssd_font->hspace;
      if ((x + ssd_font->x) > ssd_width()) {
	x = 0;
	y += ssd_font->y + ssd_font->vspace;
	if ((y + ssd_font->y) > ssd_height()) {
	  ssd_disp_update(disp);
	  getc(stdin);
	  if (j!=ssd_font->last) ssd_disp_clear();
	  y = 0;
	}
      }
    } /* for(j) */
    ssd_disp_update(disp);
    if (y||x) getc(stdin);
  }
#endif

}

/* ************************************************************
 * End of file.
 * ************************************************************/
